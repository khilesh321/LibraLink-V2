import jsPDF from "jspdf";
import html2canvas from "html2canvas";

/**
 * Calculate late fees for a transaction
 * @param {Object} transaction - Transaction object
 * @param {Array} allTransactions - All transactions for the user (for admin view) or all user transactions (for user view)
 * @returns {number} Late fees amount
 */
const calculateLateFees = (transaction, allTransactions) => {
  // Only calculate fees for issued books that are overdue
  if (transaction.action !== 'issue' || !transaction.due_date) {
    return 0;
  }

  const dueDate = new Date(transaction.due_date);
  const today = new Date();

  // Check if the book has been returned
  const bookTransactions = allTransactions.filter(t =>
    t.book_id === transaction.book_id && t.user_id === transaction.user_id
  ).sort((a, b) => new Date(b.transaction_date) - new Date(a.transaction_date));

  const transactionIndex = bookTransactions.findIndex(t => t.id === transaction.id);
  const hasReturn = bookTransactions.slice(0, transactionIndex).some(t => t.action === 'return');

  // If book has been returned, no late fees
  if (hasReturn) {
    return 0;
  }

  // If due date is in the future, no late fees
  if (dueDate > today) {
    return 0;
  }

  // Calculate days overdue
  const timeDiff = today.getTime() - dueDate.getTime();
  const daysOverdue = Math.ceil(timeDiff / (1000 * 3600 * 24));

  // 5 rupees per day
  return daysOverdue * 5;
};

/**
 * Generate a PDF from transaction data
 * @param {Array} transactions - Array of transaction objects
 * @param {Object} books - Map of book data
 * @param {Object} users - Map of user data (optional, for admin view)
 * @param {string} title - Title for the PDF
 * @param {Object} currentUser - Current user info
 */
export const generateTransactionsPDF = async (
  transactions,
  books,
  users = {},
  title,
  currentUser
) => {
  const pdf = new jsPDF();

  // Set up PDF properties
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 20;
  let yPosition = margin;

  // Add header
  pdf.setFontSize(20);
  pdf.setFont("helvetica", "bold");
  pdf.text(title, margin, yPosition);
  yPosition += 15;

  // Add user info
  pdf.setFontSize(12);
  pdf.setFont("helvetica", "normal");
  pdf.text(
    `Generated by: ${currentUser?.email || "Unknown User"}`,
    margin,
    yPosition
  );
  yPosition += 10;

  // Add generation date
  pdf.text(
    `Generated on: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
    margin,
    yPosition
  );
  yPosition += 10;

  // Add transaction count
  pdf.text(`Total Transactions: ${transactions.length}`, margin, yPosition);
  yPosition += 20;

  // Set up table headers
  const headers =
    users && Object.keys(users).length > 0
      ? [
          "Action",
          "User",
          "Book Title",
          "Author",
          "Transaction Date",
          "Due Date",
          "Late Fees",
        ]
      : ["Action", "Book Title", "Author", "Transaction Date", "Due Date", "Late Fees"];

  const columnWidths =
    users && Object.keys(users).length > 0
      ? [20, 30, 35, 30, 30, 30, 25]
      : [20, 40, 35, 30, 30, 25];

  // Draw table header
  pdf.setFontSize(10);
  pdf.setFont("helvetica", "bold");
  pdf.setFillColor(240, 240, 240);
  pdf.rect(margin, yPosition - 5, pageWidth - 2 * margin, 10, "F");

  let xPosition = margin;
  headers.forEach((header, index) => {
    pdf.text(header, xPosition + 2, yPosition + 2);
    xPosition += columnWidths[index];
  });
  yPosition += 10;

  // Draw table rows
  pdf.setFont("helvetica", "normal");
  transactions.forEach((transaction, index) => {
    // Check if we need a new page
    if (yPosition > pageHeight - 30) {
      pdf.addPage();
      yPosition = margin;
    }

    // Alternate row colors
    if (index % 2 === 0) {
      pdf.setFillColor(250, 250, 250);
      pdf.rect(margin, yPosition - 3, pageWidth - 2 * margin, 8, "F");
    }

    xPosition = margin;
    const book = books[transaction.book_id];

    // Action
    pdf.text(
      transaction.action.charAt(0).toUpperCase() + transaction.action.slice(1),
      xPosition + 2,
      yPosition + 2
    );
    xPosition += columnWidths[0];

    // User (only for admin view)
    if (users && Object.keys(users).length > 0) {
      const user = users[transaction.user_id];
      const userText = user ? `${user.email || "Unknown"}` : "Unknown User";
      pdf.text(
        userText.length > 20 ? userText.substring(0, 17) + "..." : userText,
        xPosition + 2,
        yPosition + 2
      );
      xPosition += columnWidths[1];
    }

    // Book Title
    const bookTitle = book?.title || "Unknown Book";
    pdf.text(
      bookTitle.length > 18 ? bookTitle.substring(0, 15) + "..." : bookTitle,
      xPosition + 2,
      yPosition + 2
    );
    xPosition += columnWidths[users && Object.keys(users).length > 0 ? 2 : 1];

    // Author
    const author = book?.author || "Unknown";
    pdf.text(
      author.length > 15 ? author.substring(0, 12) + "..." : author,
      xPosition + 2,
      yPosition + 2
    );
    xPosition += columnWidths[users && Object.keys(users).length > 0 ? 3 : 2];

    // Transaction Date
    const transactionDate = new Date(
      transaction.transaction_date
    ).toLocaleDateString();
    pdf.text(transactionDate, xPosition + 2, yPosition + 2);
    xPosition += columnWidths[users && Object.keys(users).length > 0 ? 4 : 3];

    // Due Date
    const dueDate = transaction.due_date
      ? new Date(transaction.due_date).toLocaleDateString()
      : "N/A";
    pdf.text(dueDate, xPosition + 2, yPosition + 2);
    xPosition += columnWidths[users && Object.keys(users).length > 0 ? 5 : 4];

    // Late Fees
    const lateFees = calculateLateFees(transaction, transactions);
    pdf.text(lateFees > 0 ? `₹${lateFees}` : "-", xPosition + 2, yPosition + 2);

    yPosition += 8;
  });

  // Add footer
  yPosition += 10;
  if (yPosition > pageHeight - 20) {
    pdf.addPage();
    yPosition = margin;
  }

  pdf.setFontSize(8);
  pdf.setTextColor(128, 128, 128);
  pdf.text(
    "Generated by LibraLink Library Management System",
    margin,
    pageHeight - 10
  );

  // Save the PDF
  const fileName = `${title.replace(/\s+/g, "_").toLowerCase()}_${
    new Date().toISOString().split("T")[0]
  }.pdf`;
  pdf.save(fileName);
};

/**
 * Generate PDF from HTML element (alternative approach)
 * @param {HTMLElement} element - The HTML element to convert to PDF
 * @param {string} fileName - Name of the PDF file
 */
export const generatePDFFromElement = async (element, fileName) => {
  try {
    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      allowTaint: true,
    });

    const imgData = canvas.toDataURL("image/png");
    const pdf = new jsPDF();

    const imgWidth = 210; // A4 width in mm
    const pageHeight = 295; // A4 height in mm
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    let heightLeft = imgHeight;

    let position = 0;

    pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;

    while (heightLeft >= 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }

    pdf.save(fileName);
  } catch (error) {
    console.error("Error generating PDF from element:", error);
    throw error;
  }
};

/**
 * Generate a CSV from transaction data
 * @param {Array} transactions - Array of transaction objects
 * @param {Object} books - Map of book data
 * @param {Object} users - Map of user data (optional, for admin view)
 * @param {string} title - Title for the CSV filename
 * @param {Object} currentUser - Current user info
 */
export const generateTransactionsCSV = (
  transactions,
  books,
  users = {},
  title,
  currentUser
) => {
  // Define CSV headers based on whether users data is provided (admin view vs user view)
  const headers =
    users && Object.keys(users).length > 0
      ? [
          "Transaction ID",
          "Action",
          "User Email",
          "User Role",
          "Book Title",
          "Book Author",
          "Book Description",
          "Transaction Date",
          "Due Date",
          "Late Fees",
          "Generated By",
          "Generated On",
        ]
      : [
          "Transaction ID",
          "Action",
          "Book Title",
          "Book Author",
          "Book Description",
          "Transaction Date",
          "Due Date",
          "Late Fees",
          "Generated By",
          "Generated On",
        ];

  // Create CSV rows
  const rows = transactions.map((transaction) => {
    const book = books[transaction.book_id];
    const user = users[transaction.user_id];

    const baseData = [
      transaction.id || transaction.book_transaction_id || "",
      transaction.action || "",
      book?.title || "Unknown Book",
      book?.author || "",
      book?.description || "",
      transaction.transaction_date
        ? new Date(transaction.transaction_date).toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
          })
        : "",
      transaction.due_date
        ? new Date(transaction.due_date).toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
          })
        : "",
      calculateLateFees(transaction, transactions) > 0 ? `₹${calculateLateFees(transaction, transactions)}` : "-",
      currentUser?.email || "Unknown User",
      new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      }),
    ];

    // Add user data for admin view
    if (users && Object.keys(users).length > 0) {
      baseData.splice(2, 0, user?.email || "Unknown User");
      baseData.splice(3, 0, user?.role || "student");
    }

    return baseData;
  });

  // Combine headers and rows
  const csvContent = [headers, ...rows]
    .map((row) =>
      row
        .map((field) => {
          // Escape fields containing commas, quotes, or newlines
          if (
            typeof field === "string" &&
            (field.includes(",") || field.includes('"') || field.includes("\n"))
          ) {
            return `"${field.replace(/"/g, '""')}"`;
          }
          return field;
        })
        .join(",")
    )
    .join("\n");

  // Create and download the CSV file
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");

  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${title.replace(/\s+/g, "_").toLowerCase()}_${
        new Date().toISOString().split("T")[0]
      }.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};
